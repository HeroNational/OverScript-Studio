import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import 'package:youtube_caption_scraper/youtube_caption_scraper.dart';

/// Service d'extraction de sous-titres YouTube.
/// Utilise youtube_explode_dart + fallback brut (json3/xml) pour auto-gen.
class YoutubeSubtitleService {
  final YoutubeExplode _yt = YoutubeExplode();

  /// Récupère les sous-titres en texte brut pour une vidéo YouTube.
  /// [languageCode] ex: 'fr' ou 'en'.
  Future<String> fetchPlainSubtitles(String url, {String languageCode = 'en'}) async {
    print('[YT] fetchPlainSubtitles url=$url lang=$languageCode');
    final videoId = VideoId(url);
    final manifest = await _yt.videos.closedCaptions.getManifest(videoId);
    print('[YT] tracks found: ${manifest.tracks.length}');
    if (manifest.tracks.isEmpty) {
      throw StateError('Aucune piste de sous-titres disponible (lang=$languageCode).');
    }

    final tracks = manifest.tracks.toList();
    final lower = languageCode.toLowerCase();
    final preferred = tracks.where((t) => t.language.code.toLowerCase().startsWith(lower)).toList();
    final others = tracks.where((t) => !t.language.code.toLowerCase().startsWith(lower)).toList();
    final candidates = [...preferred, ...others];
    print('[YT] preferred=${preferred.length} others=${others.length}');

    // On tente chaque piste jusqu'à trouver du texte.
    for (final trackInfo in candidates) {
      print('[YT] trying track lang=${trackInfo.language.code} name=${trackInfo.language.name} fmt=${trackInfo.format.formatCode} auto=${trackInfo.isAutoGenerated}');
      try {
        final track = await _yt.videos.closedCaptions.get(trackInfo);
        print('[YT] captions count=${track.captions.length}');
        final result = _flattenExplode(track.captions);
        if (result.isNotEmpty) {
          print('[YT] captions flattened length=${result.length}');
          return result;
        }
      } catch (e) {
        print('[YT] explode parse failed, fallback to raw: $e');
      }

      // Fallback brut : récupérer le JSON/XML des captions auto et parser manuellement.
      final manual = await _fetchRawCaptions(trackInfo.url, languageCode);
      if (manual.isNotEmpty) {
        print('[YT] manual fallback length=${manual.length}');
        return manual;
      }

      // Fallback XML brut (auto-gen) si JSON vide
      final xml = await _fetchXmlCaptions(trackInfo.url);
      if (xml.isNotEmpty) {
        print('[YT] xml fallback length=${xml.length}');
        return xml;
      }
    }

    // Ultimate fallback: youtube_caption_scraper (peut passer là où explode échoue)
    final scraped = await _scrapeWithCaptionScraper(url, languageCode);
    if (scraped.isNotEmpty) {
      print('[YT] scraper fallback length=${scraped.length}');
      return scraped;
    }

    final langs = tracks.map((t) => t.language.code).join(', ');
    throw StateError('Sous-titres vides pour cette vidéo. Langues disponibles: [$langs]');
  }

  Future<void> dispose() async {
    _yt.close();
  }

  String _flattenExplode(List<ClosedCaption> captions) {
    final buffer = StringBuffer();
    for (final c in captions) {
      final text = c.text.trim();
      if (text.isNotEmpty) buffer.writeln(text);
    }
    return buffer.toString().trim();
  }

  Future<String> _fetchRawCaptions(Uri baseUrl, String languageCode) async {
    // Certaines URLs renvoient déjà du JSON (fmt=srv3) ou du XML/VTT. On tente dans l'ordre.
    final candidates = <Uri>[
      baseUrl,
      baseUrl.replace(queryParameters: {...baseUrl.queryParameters, 'fmt': 'json3'}),
      baseUrl.replace(queryParameters: {
        ...baseUrl.queryParameters,
        'fmt': 'srv3',
        'lang': languageCode,
      }),
      baseUrl.replace(queryParameters: {
        ...baseUrl.queryParameters,
        'fmt': 'vtt',
        'lang': languageCode,
      }),
    ];

    for (final uri in candidates) {
      try {
        print('[YT] fetch raw captions: $uri');
        final resp = await http.get(uri);
        print('[YT] raw status=${resp.statusCode} len=${resp.body.length}');
        if (resp.statusCode != 200 || resp.body.isEmpty) continue;
        final body = resp.body.trimLeft();
        // Détection JSON
        if (body.startsWith('{')) {
          final parsed = _parseJsonCaptions(body);
          if (parsed.isNotEmpty) return parsed;
        } else if (body.contains('<text')) {
          final parsed = _parseXmlBody(body);
          if (parsed.isNotEmpty) return parsed;
        } else if (body.contains('WEBVTT')) {
          final parsed = _parseVtt(body);
          if (parsed.isNotEmpty) return parsed;
        }
      } catch (e) {
        print('[YT] raw fetch error: $e');
      }
    }
    return '';
  }

  Future<String> _fetchXmlCaptions(Uri baseUrl) async {
    print('[YT] fetch xml captions');
    final resp = await http.get(baseUrl);
    if (resp.statusCode != 200) return '';
    final body = resp.body;
    if (!body.contains('<text')) return '';
    return _parseXmlBody(body);
  }

  String _parseXmlBody(String body) {
    final regex = RegExp(r'<text[^>]*>([^<]*)</text>', multiLine: true);
    final buffer = StringBuffer();
    for (final match in regex.allMatches(body)) {
      final raw = match.group(1) ?? '';
      final text = _decodeHtmlEntities(raw.trim());
      if (text.isNotEmpty) buffer.writeln(text.replaceAll('\n', ' '));
    }
    return buffer.toString().trim();
  }

  String _parseJsonCaptions(String body) {
    try {
      final json = jsonDecode(body) as Map<String, dynamic>;
      final events = (json['events'] as List?) ?? [];
      print('[YT] json events=${events.length}');
      final buffer = StringBuffer();
      for (final e in events) {
        final root = (e['utf8'] as String?) ?? '';
        if (root.trim().isNotEmpty) {
          buffer.write(root.trim().replaceAll('\n', ' '));
          buffer.write(' ');
        }

        final segs = (e['segs'] as List?) ?? [];
        for (final s in segs) {
          final t = (s['utf8'] as String?)?.trim() ?? '';
          if (t.isNotEmpty) buffer.write('${t.replaceAll('\n', ' ')} ');
        }
        if (buffer.isNotEmpty) buffer.writeln();
      }
      final result = buffer.toString().trim();
      print('[YT] json parsed length=${result.length}');
      return result;
    } catch (e) {
      print('[YT] json parse error: $e');
      return '';
    }
  }

  String _parseVtt(String body) {
    print('[YT] parse VTT');
    final lines = const LineSplitter().convert(body);
    final buffer = StringBuffer();
    for (final line in lines) {
      final trimmed = line.trim();
      // Skip headers, cues, and timecodes
      if (trimmed.isEmpty) continue;
      if (trimmed.startsWith('WEBVTT')) continue;
      if (RegExp(r'^\d+$').hasMatch(trimmed)) continue;
      if (trimmed.contains('-->')) continue;
      buffer.writeln(trimmed);
    }
    return buffer.toString().trim();
  }

  String _decodeHtmlEntities(String input) {
    return input
        .replaceAll('&amp;', '&')
        .replaceAll('&lt;', '<')
        .replaceAll('&gt;', '>')
        .replaceAll('&quot;', '"')
        .replaceAll('&#39;', "'");
  }

  Future<String> _scrapeWithCaptionScraper(String url, String languageCode) async {
    try {
      print('[YT] scraper: listing tracks');
      final scraper = YouTubeCaptionScraper();
      final tracks = await scraper.getCaptionTracks(url);
      if (tracks.isEmpty) return '';
      final lower = languageCode.toLowerCase();
      CaptionTrack? track;
      try {
        track = tracks.firstWhere((t) => (t.languageCode ?? '').toLowerCase().startsWith(lower));
      } catch (_) {
        track = tracks.first;
      }
      print('[YT] scraper using track lang=${track.languageCode} name=${track.name}');
      final subs = await scraper.getSubtitles(track);
      if (subs.isEmpty) return '';
      final buffer = StringBuffer();
      for (final s in subs) {
        final text = (s.text ?? '').trim();
        if (text.isNotEmpty) buffer.writeln(text.replaceAll('\n', ' '));
      }
      return buffer.toString().trim();
    } catch (e) {
      print('[YT] scraper error: $e');
      return '';
    }
  }
}
